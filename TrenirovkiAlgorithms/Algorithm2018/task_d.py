# Алексей регулярно проводит собеседования с кандидатами на позицию стажёра. И хотя он провёл уже не одну сотню
# собеседований, в последнее время этот процесс даётся ему нелегко — кандидаты стали без труда решать все годами
# протестированные и отработанные задачи Алексея!
# Делать нечего, и в преддверии очередного собеседования Алексей придумал новую задачу. Имеется числовая
# последовательность, на первом шаге состоящая из двух чисел
# 1. На каждом шаге следующем шаге между каждыми двумя соседними элементами добавляется новый элемент, равный их сумме.
# После первых нескольких шагов последовательность выглядит следующим образом:
# 1 1
# 1 2 1
# 1 3 2 3 1
# 1 4 3 5 2 5 3 4 1
# На собеседовании Алексей хочет попросить кандидата написать программу, которая по заданному числу n будет
# определять, сколько раз число n будет встречаться в последовательности на n-м шаге? Алексей ещё не научился
# решать свою задачу, но слышал, что кандидат, которого он будет сейчас собеседовать, добился высоких
# результатов в спортивном программировании, поэтому, скорее всего, легко справится с этим вопросом.

# Суть решения:
# Таким образом, каждая упорядоченная пара взаимно простых чисел ровно один раз встречается в качестве соседей в
# заданной последовательности. Поэтому задача сводится к подсчёту количества упорядоченных пар взаимно простых чисел,
# дающих в сумме . Так как если p и n взаимно просты, то и p и (n - p) взаимно просты, то количество таких пар можно поставить
# в однозначное соответствие количеству чисел, взаимно простых с n, или значению функции Эйлера от n.
#
# Подсчёт же количества таких чисел является известной задачей и опирается на мультипликативность функции Эйлера:
# если  n = p1(k1) * p2(k2) * ..., то взаимно простых с n чисел будет (p1 в степ(k1) - p1(k1 - 1)) *\
#  * (p2(k2) - p2(k2 - 1)) *...
# Раскладываем  на простые множители за время  O(sqrt(n)).

def makesimpledir(n):
    simpledir = {}
    while not n % 2:
        simpledir[2] = simpledir.get(2, 0) + 1
        n = n // 2
    pred = int(n ** 0.5) + 1
    for i in range(3, pred + 1, 2):
        while not n % i:
            simpledir[i] = simpledir.get(i, 0) + 1
            n = n // i
    if n != 1:
        simpledir[n] = 1
    return simpledir

n = int(input())
if n == 1:
    res = 2
else:
    res = 1
    for key, value in makesimpledir(n).items():
        res *= (key**value - key**(value - 1))
print(res)
